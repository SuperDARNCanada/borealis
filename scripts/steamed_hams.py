#!/usr/bin/python3

"""
    Borealis Start up script
    ~~~~~~~~~~~~~~~~~~~~~~~~

    The Simpsons, Season 7 Episode 21

    :copyright: 2020 SuperDARN Canada
    :author: Keith Kotyk
"""
import argparse
import sys
import subprocess as sp
import os
import time

PYTHON_VERSION = os.environ["PYTHON_VERSION"]


def usage_msg():
    """
    Return the usage message for this process.

    This is used if a -h flag or invalid arguments are provided.

    :returns:   the usage message
    :rtype:     str
    """

    usage_message = """ steamed_hams.py [-h] experiment_module run_mode scheduling_mode_type

    Pass the module containing the experiment to steamed_hams as a required
    argument. The experiment handler will search for the module in the BOREALISPATH/experiments
    directory. It will retrieve the class from within the module (your experiment).

    Pass the mode to specify module run options and data outputs. Available modes are
    release, debug, testdata, engineeringdebug, and pythonprofiling.
    Release should be most commonly used. Note that testdata and engineeringdebug modes
    produce very large rawrf data files and will severely limit the rate of the system
    (evident by low sequences per integration period). It is recommended to only run these
    modes for short test periods due to the quantity of data produced.

    Pass in the scheduling mode type, in general common, discretionary, or special.

    """

    return usage_message


BOREALISSCREENRC = """####THIS FILE IS GENERATED BY STEAMED_HAMS.PY####

chdir $BOREALISPATH

scrollback 10000
layout autosave on
layout new borealis

caption always "%{{=ub kR}}%n %t %C:%s%a %=%l"

hardstatus alwayslastline
hardstatus string '%{{= kG}}[%{{G}}%H%? %1`%?%{{g}}][%= %{{= kw}}%-w%{{+b yk}} %n*%t%?(%u)%? %{{-}}%+w %=%{{g}}][%{{B}}%m/%d %{{W}}%C%A%{{g}}]'

# 256 colors
attrcolor b ".I"
termcapinfo xterm 'Co#256:AB=\\E[48;5;%dm:AF=\\E[38;5;%dm'
defbce on

# mouse tracking allows to switch region focus by clicking
defmousetrack on

#ctrl-arrow keys to navagate windows
bindkey ^[[1;5D focus left
bindkey ^[[1;5C focus right
bindkey ^[[1;5A focus up
bindkey ^[[1;5B focus down

screen -t "N200 Driver" bash -c "{usrp_driver}"                 # Top left
split -v
split -v
split
focus
screen -t "Signal Processing" bash -c "{rx_signal_processing}"  # Bottom left
focus
screen -t "Radar Control" bash -c "{radar_control}"             # Top middle
split
focus
screen -t "Data Write" bash -c "{data_write}"                   # Bottom middle
focus
screen -t "Experiment Handler" bash -c "{experiment_handler}"   # Right top
split
{realtime}      # extra screen created here if realtime enabled
focus
screen -t "Brian" bash -c "{brian}"                             # Right bottom
focus

detach
"""

realtime_window = """
split
focus
screen -t "Realtime" bash -c "{realtime}"                   # Right middle
"""


def steamed_hams_parser():
    """
    Creates the parser.

    :returns:   parser, the argument parser for steamed_hams.
    :rtype:     argparse.ArgumentParser
    """

    parser = argparse.ArgumentParser(usage=usage_msg())
    parser.add_argument(
        "experiment_module",
        help="The name of the module in the experiments directory that contains your "
        "Experiment class, e.g. 'normalscan'",
    )
    parser.add_argument(
        "run_mode",
        help="The mode to run, switches scons builds and some arguments to modules "
        "based on this mode. Commonly 'release'.",
    )
    parser.add_argument(
        "scheduling_mode_type",
        help="The type of scheduling time for this experiment run, e.g. 'common', "
        "'special', or 'discretionary'.",
    )
    parser.add_argument(
        "--embargo",
        action="store_true",
        help="Embargo the file (makes the CPID negative)",
    )
    parser.add_argument(
        "--kwargs",
        nargs="+",
        default="",
        help="Keyword arguments for the experiment. Each must be formatted as kw=val",
    )
    parser.add_argument(
        "--realtime-off",
        action="store_true",
        help="Disable the realtime FITACF3 and data server module",
    )

    return parser


parser = steamed_hams_parser()
args = parser.parse_args()
kwargs = " ".join(args.kwargs)

if args.run_mode == "release":
    # python optimized, no debug for regular operations
    python_opts = "-O -u"
    c_debug_opts = ""
    mode = "release"
    data_write_args = "--file-type=hdf5 --enable-raw-acfs --enable-antenna-iq"
elif args.run_mode == "debug":
    # run all modules in debug with regular operations data outputs, for testing modules
    python_opts = "-u"
    c_debug_opts = "/usr/local/cuda/bin/cuda-gdb -ex start"
    mode = "debug"
    data_write_args = "--file-type=hdf5 --enable-raw-acfs --enable-antenna-iq"
elif args.run_mode == "pythonprofiling":
    # run all modules in debug with python profiling, for optimizing python modules
    python_opts = "-O -u -m cProfile -o testing/python_testing/{module}.cprof"
    c_debug_opts = "/usr/local/cuda/bin/cuda-gdb -ex start"
    mode = "debug"
    data_write_args = "--file-type=hdf5 --enable-raw-acfs --enable-antenna-iq"
elif args.run_mode == "testdata":
    # run in scons release with python debug for tx data and print raw rf, for verifying data
    python_opts = "-u"
    c_debug_opts = ""
    mode = "release"
    data_write_args = "--file-type=hdf5 --enable-tx --enable-raw-rf"
elif args.run_mode == "engineeringdebug":
    # run all modules in debug with tx and rawrf data - this mode is very slow
    python_opts = "-u"
    c_debug_opts = "/usr/local/cuda/bin/cuda-gdb -ex start"
    mode = "debug"
    data_write_args = "--file-type=hdf5 --enable-bfiq --enable-antenna-iq --enable-raw-rf --enable-tx;"
elif args.run_mode == "filterdata":
    # run all modules in debug with rawrf, antennas_iq, and filter stage data.
    python_opts = "-u"
    c_debug_opts = "/usr/local/cuda/bin/cuda-gdb -ex start"
    mode = "debug"
    data_write_args = "--file-type=hdf5 --enable-raw-rf --enable-antenna-iq"
else:
    print(f"Mode {args.run_mode} is unknown. Exiting without running Borealis")
    sys.exit(-1)

# Configure python first, starting with options for each module
options = {
    "brian": "",
    "experiment_handler": f"{args.experiment_module} {args.scheduling_mode_type}",
    "radar_control": "",
    "data_write": f"{data_write_args}",
    "realtime": "",
    "rx_signal_processing": "",
    "usrp_driver": f'{mode} --c_debug_opts="{c_debug_opts}"',
}

if args.embargo:
    options["experiment_handler"] += " --embargo"
if args.kwargs:
    options["experiment_handler"] += f" --kwargs {kwargs}"
if args.realtime_off:
    options["brian"] += " --realtime-off"

modules = {}
for mod in options.keys():
    py_opts = python_opts.format(module=mod)
    modules[mod] = (
        f"source borealis_env{PYTHON_VERSION}/bin/activate; "
        f"python{PYTHON_VERSION} {py_opts} src/{mod}.py {options[mod]}"
    )

# Bypass the python wrapper to run cuda-gdb
if mode == "debug":
    modules["usrp_driver"] = f"source mode {mode}; {c_debug_opts} usrp_driver"

# Temporary fix to give us access to exactly what's printed to console from Borealis
log_dir = "/data/borealis_logs"
for mod in modules.keys():
    modules[mod] += f" 2>&1 | tee {log_dir}/{mod}.log"

# Ready the command for adding a realtime window, if it is not disabled.
if args.realtime_off:
    modules["realtime"] = ""
else:
    modules["realtime"] = realtime_window.format(realtime=modules["realtime"])

# Add the commands to the script and write to file
screenrc = BOREALISSCREENRC.format(**modules)
screenrc_file = os.environ["BOREALISPATH"] + "/borealisscreenrc"
with open(screenrc_file, "w") as f:
    f.write(screenrc)

# When using OpenSUSE 15.5, there is a file generated on boot in shared memory that must be kept
sp.call("find /dev/shm/* -type f -not -name 'sem.haveged_sem' -delete", shell=True)
# Clean up any residuals in shared memory and dead screens
sp.call("screen -X -S borealis quit", shell=True)

# Give the os a chance to free all previously used sockets, etc.
time.sleep(1)

# Lights, camera, action!
screen_launch = "screen -S borealis -c " + screenrc_file
sp.call(screen_launch, shell=True)
